/*
 * Math functions
 * ver 12
 * see https://github.com/kristianpaul/osgps/blob/master/CMatrix3.cpp to:
 * 1) inspire why eigen uses high memory
 * 2) see mat inverse code
 */

#include "./nsrMathLib.h"
#include "nsrCore.h"
#include <string.h> //memset
#include <assert.h>

#undef TAG
#define TAG "Cpp:MathLib:"

#ifdef __cplusplus
extern "C" {
#endif

static bool debug_mode = false;
typedef double Tfloat;
#define msg(...) if(debug_mode) LOGV(TAG, __VA_ARGS__);
int allocated_size = 0;
////////////////////////////
//Allocations and disallocations

void Matrice::initialize(int init_rows, int init_cols, Tfloat* raw_pointer, Tfloat** start_pointers, bool matrix_indices_start_by_one)
{
	int i, init_starters;

	msg(" Matrice::initialize() ...");
	msg(" allocating root:() ...");
	p = (Matheader*)malloc(sizeof(Matheader)); ///////////////////////////
	allocated_size += sizeof(Matheader);
	memset(p, 0, sizeof(Matheader));
	p->error = 0;
	p->autoGenerated = false;

	p->r = init_rows;
	p->c = init_cols;

#ifndef MATLAB_ARRAYS_ENABLED
	assert(matrix_indices_start_by_one == false);
#endif
	p->matrix_indices_start_by_one = matrix_indices_start_by_one;

	//Allocate matrix main memory//
	p->memory_size = init_rows * init_cols * sizeof(Tfloat);

	if(raw_pointer != NULL && start_pointers != NULL) { //(used in DefineMatriceXxX)
		p->raw_pointer = raw_pointer;
	} else if(raw_pointer == NULL && start_pointers != NULL) { //(used when getting mat refs)
		p->raw_pointer = start_pointers[0];
	} else if(raw_pointer != NULL && start_pointers == NULL) { //(not used)
		p->raw_pointer = raw_pointer;
	} else { //both NULL(usually used)
		if(init_rows > 0 && init_cols > 0) {
			msg(" allocating 2D Memory (%ix%i)(%iB) ...", init_rows, init_cols, init_rows * init_cols * (int)sizeof(Tfloat));
			p->raw_pointer = (Tfloat*)malloc(init_rows * init_cols * sizeof(Tfloat)); ///////////////////////////
			allocated_size += init_rows * init_cols * sizeof(Tfloat);
			p->raw_pointer_made_with_malloc = 1;
		}
	}

	//Allocate matrix row/col starts//
#ifdef STORE_ROWWISE
	init_starters = init_rows;
#else //STORE_COLWISE
	init_starters = init_cols;
#endif
	p->max_starters = init_starters;

	if(start_pointers != NULL) { //(used when getting mat refs or in DefineMatriceXxX)
		p->start_pointers = start_pointers;
	} else { //(usually used)
		if(init_rows > 0) {
			msg(" allocating 1D row/col starts for (%ix%i)(%iB) ...", init_rows, init_cols, init_starters * (int)sizeof(Tfloat*));
			p->start_pointers = (Tfloat**)malloc(init_starters * sizeof(Tfloat*)); //////////////////////
			allocated_size += init_starters * sizeof(Tfloat*);
			p->start_pointers_made_with_malloc = 1;

#ifdef STORE_ROWWISE
			for(i = 0; i < init_rows; i++)
				p->start_pointers[i] = &p->raw_pointer[i * init_cols];
#else //STORE_COLWISE
			for(i = 0; i < init_cols; i++)
				p->start_pointers[i] = &p->raw_pointer[i * init_rows];
#endif

		} else
			p->start_pointers = NULL;
	}

	msg("\n");
}

void Matrice::reinit(int init_rows, int init_cols)
{
	int i, init_starters;

	p->error = 0;

	if(p->r == init_rows && p->c == init_cols) //no need
		return;

	msg(" Matrice::reinit() ...");

	//if main matrix body need more memory/////////
	if(p->memory_size < init_rows * init_cols * sizeof(Tfloat) || p->raw_pointer == NULL) {
		//printf("%i(%p)->%ix%ix8=%i->", p->memory_size, p->raw_pointer, init_rows, init_cols, init_rows*init_cols*8); fflush(stdout);

		//free
		if(p->raw_pointer != NULL) {
			msg(" Matrix body needs more memory, first Freeing (");
			msg("%i, %i) ...", p->r, p->c);
			if(p->raw_pointer_made_with_malloc == 1) {
				free(p->raw_pointer); //free main matrix memory
				allocated_size -= p->memory_size;
				p->raw_pointer_made_with_malloc = 0;
			}
			p->raw_pointer = NULL;
		}

		//Allocate matrix main memory
		p->memory_size = init_rows * init_cols * sizeof(Tfloat);
		msg(" allocating 2D Memory (%ix%i)(%iB) ...", init_rows, init_cols, init_rows * init_cols * (int)sizeof(Tfloat));
		p->raw_pointer = (Tfloat*)malloc(init_rows * init_cols * sizeof(Tfloat)); /////////////////////////
		//printf("OK\n"); fflush(stdout);
		allocated_size += init_rows * init_cols * sizeof(Tfloat);
		p->raw_pointer_made_with_malloc = 1;
	}

	//if matrix row/col starts need more memory/////////
#ifdef STORE_ROWWISE
	init_starters = init_rows;
#else //STORE_COLWISE
	init_starters = init_cols;
#endif
	if(p->max_starters < init_starters || p->start_pointers == NULL) {
		//free
		if(p->start_pointers != NULL) {
			msg(" Matrix first rows/cols needs more memory, first Freeing 1D (");
			msg("%i, %i) ...", p->r, p->c);
			if(p->start_pointers_made_with_malloc == 1) {
				free(p->start_pointers); //free row starts memory
				allocated_size -= p->max_starters * sizeof(Tfloat*);
				p->start_pointers_made_with_malloc = 0;
			}
			p->start_pointers = NULL;
		}

		//Allocate matrix row/col starters
		p->max_starters = init_starters;
		msg(" allocating 1D row/col starts for (%ix%i)(%iB) ...", init_rows, init_cols, init_starters * (int)sizeof(Tfloat*));
		p->start_pointers = (Tfloat**)malloc(init_starters * sizeof(Tfloat*)); ///////////////////////
		allocated_size += init_starters * sizeof(Tfloat*);
		p->start_pointers_made_with_malloc = 1;
	}

#ifdef STORE_ROWWISE
	for(i = 0; i < init_rows; i++)
		p->start_pointers[i] = &p->raw_pointer[i * init_cols];
#else //STORE_COLWISE
	for(i = 0; i < init_cols; i++)
		p->start_pointers[i] = &p->raw_pointer[i * init_rows];
#endif

	if(p->r != 0 && p->c != 0)
		msg(" Reinit done !(%i, %i)->(%i, %i)", p->r, p->c, init_rows, init_cols);

	p->r = init_rows;
	p->c = init_cols;
	//   p->memory_size=init_rows*init_cols * sizeof(Tfloat);

	msg("\n");
}

void Matrice::disinit()
{
	if(p != NULL) {
		if(p->disable_disinit_once > 0) {
			msg(" Matrice::disinit disabled once ...\n");
			p->disable_disinit_once = 0;
			return;
		}

		msg(" (%i)Matrice::disinit() ...", allocated_size);
		msg("(%ix%i:=%ix%i) ...", p->r, p->c, p->memory_size / (int)sizeof(Tfloat), (int)sizeof(Tfloat));

		//(*this).print();
		if(debug_mode) *this = -110; //init all elements with -110 so that matrix usage be recognized as error after disinit
		msg(" disinit2 ...");

		if(p->raw_pointer != NULL) {
			if(p->raw_pointer_made_with_malloc == 1) {
				msg(" freeing main body:(%iB) ..."/*, p->raw_pointer*/, p->memory_size);
				free(p->raw_pointer);
				p->raw_pointer_made_with_malloc = 0;
				allocated_size -= p->memory_size;
			}
			p->raw_pointer = NULL;
		}
		p->memory_size = 0;

		if(p->start_pointers != NULL) {
			if(p->start_pointers_made_with_malloc == 1) {
				msg(" freeing first rows:(%iB) ..."/*, p->start_pointers*/, p->max_starters * (int)sizeof(Tfloat*));
				free(p->start_pointers);
				p->start_pointers_made_with_malloc = 0;
				allocated_size -= p->max_starters * sizeof(Tfloat*);
			}
			p->start_pointers = NULL;
		}
		p->max_starters = 0;

		msg(" disinit4 ...");
		p->r = 0;
		p->c = 0;

		msg(" freeing root:() ...");
		free(p);
		allocated_size -= sizeof(Matheader);
		p = NULL;
		msg(" disinit5 ...");
		msg("\n");
	} else {
		msg(" already NULL ...\n");
	}
}

////////////////////////////
//Constructors and destructors

Matrice::Matrice(const char* flag, int dimension)
{
	Tfloat init = 0.0;
	int i, j;
	//reinit(dimension, dimension);
	initialize(dimension, dimension);
	switch(flag[0]) {
		case 'I':
			for(i = 0; i < dimension; i++)
				for(j = 0; j < dimension; j++)
					elem(i, j) = (i == j ? 1 : 0);
			break;
		case 'R':
			for(i = 0; i < dimension; i++)
				for(j = 0; j < dimension; j++)
					elem(i, j) = rand() % 10 + 1;
			break;
	}
}

Matrice::~Matrice()
{
	disinit();
}

////////////////////////////
//Copies and moves//////////

//copy constructors are called when equal(=) operator is used at the time of Matrice declaration
//MOVE CONSTRUCTOR NOT USED, USE (Matrice &a = b) FOR DECLERATIVE COPY BY REFERENCE
Matrice::Matrice(const Matrice &M)
{
	int i;
	msg(" Copy constructor copied(%ix%i)!!!!!\n", M.p->r, M.p->c);

	initialize(M.rows(), M.cols());

	*this = M; //reusing overloaded "="
	/*
	p->error = M.p->error;

	#ifdef STORE_ROWWISE
	for(i=0; i<M.p->r; i++)
		memcpy(p->start_pointers[i], M.p->start_pointers[i], M.p->c * sizeof(Tfloat));
	#else //STORE_COLWISE
	for(i=0; i<M.p->c; i++)
		memcpy(p->start_pointers[i], M.p->start_pointers[i], M.p->r * sizeof(Tfloat));
	#endif
	*/
}

//deep copy, use for direct assignments: a = b
//Note: Copy-Move constructor is called instead when a Matrice is being defined(like: Matrice a = b;)
//operator = is already overloaded by system, which just copies matrix elements
//Matrice& in output is just for a=b=c syntax
//using Matrice in output will cause no change to output matrice, or infinite delete loop
//You can also use void(not Matrice) as output if you don't need a=b=c syntax

Matrice &Matrice::operator = (const Matrice &cm)
{
	int i, j;

	/*
	//MOVE DEPRECATED, USE << OPERATOR FOR DECLERATIVE MOVE
	//for speed, use IGNOR_MOVE, so that in matrix assignments, copy takes place instead of costly malloc ???
	#define IGNOR_MOVE

	#ifdef IGNOR_MOVE
	cm.p->autoGenerated=false;
	#endif

	if(cm.p->autoGenerated == true) {  //move
	    msg(" Matrice::\"=\" moved(%ix%i)!!!!!\n", cm.p->r, cm.p->c);
	    //msg(" ===========(%i,%i)\n", cm.rows(), cm.cols());

	    disinit(); //allows a new initialize
	    initialize(cm.rows(), cm.cols(), cm.p->raw_pointer, cm.p->start_pointers); //??? check again

	    //p=cm.p;
	    //cm.p = NULL;

	    p->error=cm.p->error;
	    cm.p->raw_pointer = NULL;
	    cm.p->start_pointers = NULL;
	} else*/
	{
		//copy
		msg(" Matrice::\"=\" copied(%ix%i)!!!!!\n", cm.p->r, cm.p->c);

		if(this != &cm) {
			//LOGV("","\n\n Before reinit this(%i,%i):\n\n\n",rows(),cols());
			reinit(cm.rows(), cm.cols());
			//LOGV("","\n\n After reinit this(%i,%i):\n\n\n",rows(),cols());
			p->error = cm.p->error;

#ifdef STORE_ROWWISE
			for(i = 0; i < cm.p->r; i++)
				memcpy(p->start_pointers[i], cm.p->start_pointers[i], cm.p->c * sizeof(Tfloat));
#else //STORE_COLWISE
			for(i = 0; i < cm.p->c; i++)
				memcpy(p->start_pointers[i], cm.p->start_pointers[i], cm.p->r * sizeof(Tfloat));
#endif
		}
	}

	return *this; //just for a=b=c syntax
}

//shallow copy, use for reference assignments: a << b + c, a << b.diag(), ...
void operator << (Matrice &output, const Matrice &M)
{
	msg(" Matrice::\"<<\"\n");
	bool start_by_one = output.p->matrix_indices_start_by_one;
	output.disinit();
	output.p = M.p;
	output.p->matrix_indices_start_by_one = start_by_one;
}

//from this row, matrices at most use reinit()

////////////////////////////
//Element actions///////////

int Matrice::rows() const
{
	if(!p)
		return 0;

	return p->r;
}

int Matrice::cols() const
{
	if(!p)
		return 0;

	return p->c;
}

int size(Matrice &M, int dim)
{
	if(dim == 1) { //rows
		return M.p->r;
	}

	if(dim == 2) { //cols
		return M.p->c;
	}
	return 0;
}

////////////////////////////
//Visualization/////////////
void Matrice::print(const char* name, int group_size)
{
	int i, j;

	if(p == NULL) {
		LOGI(TAG, "[NULL]\n");
		return;
	}

	if(name == NULL)
		//LOGI(TAG, "[");
		printf("(%ix%i)\n[", rows(), cols());
	else
		//LOGI(TAG, "%s[", name);
		printf("%s(%ix%i)\n[", name, rows(), cols());

	for(i = 0; i < rows(); i++) {
		for(j = 0; j < cols(); j++) {
			if(i != (rows() - 1) || j != (cols() - 1)) {
				//LOGI(TAG, "%f, ", elem(i, j));
				printf("%f, ", elem(i, j));
			} else {
				//LOGI(TAG, "%f]", elem(i, j));
				printf("%f]", elem(i, j));
			}

			if(group_size != 0 && (j + 1) % group_size == 0) printf("   ");
		}
		//LOGI(TAG, " \n ");
		printf(" \n ");
		if(group_size != 0 && (i + 1) % group_size == 0) printf("\n");
	}
	//LOGI(TAG, "\n");
	printf("\n");

}

#if defined(_WIN32) || defined(__linux__) || defined(__ANDROID__)
//verified
void Matrice::save(const char* filepath)
{
	int i, j;

	if(p == NULL)
		return;

	FILE* f = fopen(filepath, "w");
	for(i = 0; i < rows(); i++) {
		for(j = 0; j < cols(); j++) {
			fprintf(f, "%f,", elem(i, j));
		}
		fprintf(f, "\n");
	}
	fprintf(f, "\n");
	fclose(f);
}

//verified
void Matrice::load(const char* filepath)
{
	int i, len, rows, cols, row, col, last_num_start;
	FILE* f = fopen(filepath, "r");
#define BUFFER_SIZE 100
	char lineBuf[BUFFER_SIZE];

	//First determine rows and cols count
	rows = 0;
	while(fgets(lineBuf, BUFFER_SIZE - 1, f)) {
		len = strlen(lineBuf);
		if(len == 0) break;
		if(lineBuf[0] == '\r' || lineBuf[0] == '\n') break;

		if(rows == 0) { //in first row
			cols = 0;
			for(i = 0; i < len; i++)
				if(lineBuf[i] == ',') cols++;
		}

		rows++;
	}

	reinit(rows, cols);

	row = 0;
	while(fgets(lineBuf, BUFFER_SIZE - 1, f)) {
		len = strlen(lineBuf);
		if(len == 0) break;

		col = 0;
		last_num_start = 0;
		for(i = 0; i < len; i++) {
			if(lineBuf[i] == ',') {
				elem(row, col) = atof(&lineBuf[last_num_start]);
				last_num_start = i + 1;
				col++;
			}
		}

		row++;
	}

	fclose(f);
}
#endif

////////////////////////////
//Transposing///////////////

//verified
Matrice Matrice::t()
{
	int row, col;

	Matrice trans(cols(), rows()); ////////////////////////////////////////////////////////////////////////////////////////
	trans.p->autoGenerated = true;
	for(row = 0; row < rows(); row++)
		for(col = 0; col < cols(); col++)
			trans.elem(col, row) = elem(row, col);

	return trans;
}

Matrice Matrice::transpose()
{
	return t();
}

////////////////////////////
//Get subsets of the matrix/////

Matrice Matrice::col(int c)
{
	int i, len;
	len = rows();
	Matrice _col(len, 1); ///////////////////////////////////////////////

#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one)
		c--;
#endif

	for(i = 0; i < len; i++)
		_col.elem(i, 0) = elem(i, c);

	return _col;
}

Matrice Matrice::colr(int c)
{
	int i, len;
	Tfloat **start_pointers;
#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one)
		c--;
#endif

	len = rows();

#ifdef STORE_ROWWISE
	start_pointers = (Tfloat**)malloc(len * sizeof(Tfloat*)); ///////////////////////
	allocated_size += len * sizeof(Tfloat*);
	for(i = 0; i < len; i++)
		start_pointers[i] = &elem(i, c);
#else //STORE_COLWISE
	start_pointers = (Tfloat**)malloc(sizeof(Tfloat*)); ///////////////////////////
	allocated_size += sizeof(Tfloat*);
	start_pointers[0] = &elem(0, c);
#endif
	Matrice result(len, 1, NULL, start_pointers);

	result.p->start_pointers_made_with_malloc = 1;

	result.p->disable_disinit_once = 1; //disable desctructor on return, so that we can get it by reference

	return result;
}

Matrice Matrice::row(int c)
{
	int i, len;
	len = cols();
	Matrice _row(1, len); ///////////////////////////////////////////////

#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one)
		c--;
#endif

	for(i = 0; i < len; i++)
		_row.elem(0, i) = elem(c, i);

	return _row;
}

Matrice Matrice::rowr(int r)
{
	int i, len;
	Tfloat **start_pointers;
#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one)
		r--;
#endif

	len = cols();

#ifdef STORE_ROWWISE
	start_pointers = (Tfloat**)malloc(sizeof(Tfloat*)); /////////////////////////
	allocated_size += sizeof(Tfloat*);
	start_pointers[0] = &elem(r, 0);
#else //STORE_COLWISE
	start_pointers = (Tfloat**)malloc(len * sizeof(Tfloat*)); /////////////////////
	allocated_size += len * sizeof(Tfloat*);
	for(i = 0; i < len; i++)
		start_pointers[i] = &elem(r, i);
#endif
	Matrice result(1, len, NULL, start_pointers);

	result.p->start_pointers_made_with_malloc = 1;

	result.p->disable_disinit_once = 1; //disable desctructor on return

	return result;
}

Matrice Matrice::subs(int min_row, int max_row, int min_col, int max_col)
{
	int i, j;
	Matrice _subs(max_row - min_row + 1, max_col - min_col + 1); ///////////////////////////////////////////////

#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one) {
		min_row--; min_col--;
		max_row--; max_col--;
	}
#endif

	for(i = min_row; i <= max_row; i++)
		for(j = min_col; j <= max_col; j++)
			_subs.elem(i - min_row, j - min_col) = elem(i, j);

	return _subs;
}

Matrice Matrice::subsr(int min_row, int max_row, int min_col, int max_col)
{
	int i, rows, cols;
	Tfloat **start_pointers;

	rows = max_row - min_row + 1;
	cols = max_col - min_col + 1;

#ifdef MATLAB_ARRAYS_ENABLED
	if(p->matrix_indices_start_by_one) {
		min_row--; min_col--;
		max_row--; max_col--;
	}
#endif

#ifdef STORE_ROWWISE
	start_pointers = (Tfloat**)malloc(rows * sizeof(Tfloat*)); ///////////////////
	allocated_size += rows * sizeof(Tfloat*);
	for(i = 0; i < rows; i++)
		start_pointers[i] = &elem(i + min_row, min_col);
#else //STORE_COLWISE
	start_pointers = (Tfloat**)malloc(cols * sizeof(Tfloat*)); ///////////////////
	allocated_size += cols * sizeof(Tfloat*);
	for(i = 0; i < cols; i++)
		start_pointers[i] = &elem(min_row, i + min_col);
#endif
	Matrice result(rows, cols, NULL, start_pointers);

	result.p->start_pointers_made_with_malloc = 1;

	result.p->disable_disinit_once = 1; //disable desctructor on return

	return result;
}

Matrice Matrice::diag()
{
	int i, len;
	len = nsrMin(rows(), cols());
	Matrice _diag(len, 1); ///////////////////////////////////////////////

	for(i = 0; i < len; i++)
		_diag.elem(i, 0) = elem(i, i);

	return _diag;
}

Matrice Matrice::diagr()
{
	int i, len;
	len = nsrMin(rows(), cols());

	Tfloat **start_pointers;
	start_pointers = (Tfloat**)malloc(len * sizeof(Tfloat*)); //////////////////
	allocated_size += len * sizeof(Tfloat*);
	for(i = 0; i < len; i++)
		start_pointers[i] = &elem(i, i);

	Matrice result(len, 1, NULL, start_pointers);
	result.p->start_pointers_made_with_malloc = 1;

	result.p->disable_disinit_once = 1; //disable desctructor on return

	return result;
}

///////////////////////////
//Various fillings of matrix

void Matrice::fill(Tfloat val)
{
	int i, j;
	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++)
			elem(i, j) = val;
}

void Matrice::fill2(Tfloat first, ...)
{
	int i, j;
	va_list args;
	va_start(args, first);

	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++)
			elem(i, j) = ((i == 0 && j == 0) ? first : va_arg(args, Tfloat));
	va_end(args);

	return;
}

void Matrice::fill3(int dst_min_row, int dst_max_row, int dst_min_col, int dst_max_col,
					Matrice &A, int src_min_row, int src_max_row, int src_min_col, int src_max_col)
{
	int i, j;
	assert(!(src_max_row - src_min_row != dst_max_row - dst_min_row) ||
		   (src_max_col - src_min_col != dst_max_col - dst_min_col));

	for(i = dst_min_row; i <= dst_max_row; i++)
		for(j = dst_min_col; j <= dst_max_col; j++)
			elem(i, j) = A.elem(i - dst_min_row + src_min_row, j - dst_min_col + src_min_col);
}

void Matrice::fillRand(Tfloat min, Tfloat max)
{

	int i, j;
	for(i = 0; i < rows(); i++) {
		for(j = 0; j < cols(); j++) {
			elem(i, j) = RAND(min, max);
		}
	}
	return;
}

void Matrice::fillEye()
{
	int i, j;
	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++)
			elem(i, j) = (i == j ? 1. : 0);
	return;
}

Matrice zeros(int rows, int cols)
{
	int i, j;
	if(cols < 0) cols = rows;

	Matrice m(rows, cols);////////////////////////////////////////////////////////////////////////////////////////
	m.p->autoGenerated = true;

	for(i = 0; i < rows; i++)
		for(j = 0; j < cols; j++)
			m.elem(i, j) = 0.;

	return m;
}

Matrice ones(int rows, int cols)
{
	int i, j;
	if(cols < 0) cols = rows;

	Matrice m(rows, cols);////////////////////////////////////////////////////////////////////////////////////////
	m.p->autoGenerated = true;

	for(i = 0; i < rows; i++)
		for(j = 0; j < cols; j++)
			m.elem(i, j) = 1.;

	return m;
}

Matrice eye(int rows, int cols)
{
	int i, j;
	if(cols < 0) cols = rows;

	Matrice m(rows, cols);////////////////////////////////////////////////////////////////////////////////////////
	m.p->autoGenerated = true;

	for(i = 0; i < rows; i++)
		for(j = 0; j < cols; j++)
			m.elem(i, j) = (i == j ? 1. : 0.);

	return m;
}

Matrice createmat(int rows, int cols, Tfloat first, ...)
{
	int i, j;
	Matrice m(rows, cols);////////////////////////////////////////////////////////////////////////////////////////
	m.p->autoGenerated = false;

	va_list args;
	va_start(args, first);

	for(i = 0; i < rows; i++)
		for(j = 0; j < cols; j++)
			m.elem(i, j) = ((i == 0 && j == 0) ? first : va_arg(args, Tfloat));
	va_end(args);

	return m;
}

////////////////////////////
//Old API///////////////////

void Matrice::equal(const Matrice &A)
{
	int i, j;
	int _rows, _cols;
	_rows = A.rows(); _cols = A.cols();

	reinit(_rows, _cols);
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) = A.elemc(i, j);
}

int Matrice::equal2(const Matrice &A, char oper)
{
	int i, j;
	int _rows, _cols;
	_rows = A.rows(); _cols = A.cols();

	if(oper == '\'') {
		reinit(_cols, _rows); //reverse
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				elem(j, i) = A.elemc(i, j);
	}

	if(oper == '-') {
		reinit(_rows, _cols);
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				elem(i, j) = -A.elemc(i, j);
	}
	return 0;
}

void Matrice::equal3(Matrice &A, char oper, Matrice &B)
{
	int i, j, k;
	int _rows, _cols, _cols2;
	_rows = A.rows(); _cols = A.cols(); _cols2 = B.cols();

	if(oper == '+') {
		reinit(_rows, _cols);
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				elem(i, j) = A.elemc(i, j) + B.elemc(i, j);
	}

	if(oper == '-') {
		reinit(_rows, _cols);
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				elem(i, j) = A.elemc(i, j) - B.elemc(i, j);
	}

	//matrix multiplication
	if(oper == '*') {
		if(_cols == B.rows()) {
			reinit(_rows, B.cols());

			for(i = 0; i < _rows; ++i) {
				for(j = 0; j < _cols2; ++j) {
					elem(i, j) = 0;
					for(k = 0; k < _cols; ++k)
						elem(i, j) += A.elemc(i, k) * B.elemc(k, j);
				}
			}
		} else {
			LOGE(TAG, "\nSorry!!!! Matrix multiplication can't be done(%i,%i<->%i,%i)\n", _rows, _cols, B.rows(), B.cols());
		}
	}

	//cross product
	if(oper == 'x') {
		reinit(3, 1);
		elem(0, 0) = A[1] * B[2] - A[2] * B[1];
		elem(1, 0) = A[2] * B[0] - A[0] * B[2];
		elem(2, 0) = A[0] * B[1] - A[1] * B[0];
		//msg("((%f,%f,%f))", a, b, c);
	}
}

void Matrice::equaldiag(const Matrice &A)
{
	int i, len;
	reinit(nsrMin(A.rows(), A.cols()), 1);
	len = nsrMin(A.rows(), A.cols());
	for(i = 0; i < len; i++)
		elem(i, 0) = A.elemc(i, i);
}

void Matrice::scaleDiag(Tfloat scale)
{
	int i, len;
	len = nsrMin(rows(), cols());
	for(i = 0; i < len; i++)
		elem(i, i) *= scale;
}

//output is a column vector
void Matrice::equalrow(const Matrice &A, int row)
{
	int i, _cols;
	_cols = A.cols();

	reinit(_cols, 1);
	for(i = 0; i < _cols; i++)
		elem(i, 0) = A.elemc(row, i);
}

//output is a column vector
void Matrice::equalcol(const Matrice &A, int col)
{
	int i, _rows;
	_rows = A.rows();

	reinit(_rows, 1);
	for(i = 0; i < _rows; i++)
		elem(i, 0) = A.elemc(i, col);
}

//input is a column or row vector
void Matrice::rowequal(int row, const Matrice &A)
{
	int i, _cols;
	_cols = cols();
	for(i = 0; i < _cols; i++)
		elem(row, i) = A.elemc(0, i);
}

//input is a column vector
void Matrice::colequal(int col, const Matrice &A)
{
	int i, _rows;
	_rows = A.rows();

	if(rows() != _rows) {
		LOGE(TAG, "\nSorry!!!! colequal can't be done(%i<->%i)\n", rows(), A.rows());
		return;
	}

	for(i = 0; i < _rows; i++)
		elem(i, col) = A.elemc(i, 0);
}

Tfloat Matrice::rowMean(int row)
{
	int i, _cols;
	_cols = cols();

	Tfloat mean = 0;
	for(i = 0; i < _cols; i++)
		mean += elem(row, i);
	mean /= _cols;
	return mean;
}

Tfloat Matrice::colMean(int col)
{
	int i, _rows;
	_rows = rows();

	Tfloat mean = 0;
	for(i = 0; i < _rows; i++)
		mean += elem(i, col);
	mean /= _rows;
	return mean;
}

////////////////////////////
//New API///////////////////

Matrice &Matrice::operator = (const Tfloat d)
{
	int i, j;
	for(i = 0 ; i < rows(); i++)
		for(j = 0; j < cols(); j++)
			elem(i, j) = d;
	return *this; //just for a=b=2 syntax
}

Matrice Matrice::operator + (const Matrice &M)
{
	int i, j;
	int _rows, _cols;
	_rows = rows();
	_cols = cols();

	if((_rows != M.rows()) || (_cols != M.cols())) LOGE(TAG, "\n Wrong size for matrix addition \n ");

	Matrice result(rows(), cols()); ////////////////////////////////////////////////////////////////////////////////////////

	result.p->autoGenerated = true;

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			result.elem(i, j) = elem(i, j) + M.elemc(i, j);
	//LOGV("","\n\n autoGenerated is : %i\n\n\n",result.p->autoGenerated);
	//LOGV("","\n\n (%i) \n\n ",result.p->memory_size);
	return result;
}

Matrice Matrice::operator + (const Tfloat rval)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice result(_rows, _cols); ////////////////////////////////////////////////////////////////////////////////////////

	result.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			result.elem(i, j) = elem(i, j) + rval;

	return result;
}

Matrice &Matrice::operator += (Matrice &rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) += rhs.elem(i, j);

	return *this;
}

Matrice &Matrice::operator += (const Tfloat rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) += rhs;

	return *this;
}

Matrice Matrice::operator - (const Matrice &M)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	if((_rows != M.rows()) || (_cols != M.cols())) LOGE(TAG, " Wrong size for matrix subtraction!\n");

	Matrice result(_rows, _cols); ////////////////////////////////////////////////////////////////////////////////////////
	result.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			result.elem(i, j) = elem(i, j) - M.elemc(i, j);

	return result;
}

Matrice Matrice::operator - (const Tfloat rval)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice result(_rows, _cols); ////////////////////////////////////////////////////////////////////////////////////////
	//   result = (*this);
	result.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			result.elem(i, j) = elem(i, j) - rval;

	return result;
}

Matrice &Matrice::operator -= (Matrice &rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) -= rhs.elem(i, j);

	return *this;
}

Matrice &Matrice::operator -= (const Tfloat rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) -= rhs;

	return *this;
}

Matrice operator - (Matrice &BM)
{
	int i, j;
	int _rows, _cols;
	_rows = BM.rows(); _cols = BM.cols();

	Matrice m(_rows, _cols);////////////////////////////////////////////////////////////////////////////////////////
	m.p->autoGenerated = true;

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			m.elem(i, j) = -BM.elem(i, j);

	return m;
}

Matrice Matrice::operator * (const Matrice &M)
{
	int i, j, k;
	int _rows, _cols, _rows2, _cols2;
	_rows = rows(); _cols = cols();
	_rows2 = M.rows(); _cols2 = M.cols();
	Tfloat sum = 0;
	if((_cols != _rows2)) LOGE(TAG, " Wrong matrix size for multiplication(%i, %i)<->(%i, %i))!\n", _rows, _cols, _rows2, _cols2);
	Matrice a(_rows, _cols2);/////////////////////////////////////////////////////////////////////////////////////////////
	a.p->autoGenerated = true;
	for(i = 0; i < _rows; i++) {
		for(j = 0; j < _cols2; j++) {
			sum = 0.0;
			for(k = 0; k < _cols; k++)
				sum += elem(i, k) * M.elemc(k, j);
			a.elem(i, j) = sum;
		}
	}
	return a;
}

Matrice Matrice::operator * (Tfloat d)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice a(_rows, _cols); ////////////////////////////////////////////////////////////////////////////////////////
	a.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			a.elem(i, j) = elem(i, j) * d;

	return a;
}

Matrice operator *(Tfloat f, Matrice &BM)
{
	return BM * f;
}

Matrice &Matrice::operator *= (Tfloat rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) *= rhs;

	return *this;
}

Matrice Matrice::operator / (Matrice &M)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice a(_rows, _cols); //////////////////////////////////////////////////////////////////////////////////////////////
	a.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			a.elem(i, j) = elem(i, j) / M.elem(i, j);

	return a;
}

Matrice Matrice::operator / (Tfloat d)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice a(_rows, _cols); //////////////////////////////////////////////////////////////////////////////////////////////
	a.p->autoGenerated = true;
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			a.elem(i, j) = elem(i, j) / d;

	return a;
}

Matrice &Matrice::operator /= (Tfloat rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			elem(i, j) /= rhs;

	return *this;
}

//verified
Matrice Matrice::operator^ (const Tfloat rhs)
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	Matrice a(_rows, _cols); //////////////////////////////////////////////////////////////////////////////////////////////
	register Tfloat var;
	a.p->autoGenerated = true;

	if(rhs == (Tfloat)2.) {
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++) {
				var = elemc(i, j);
				a.elem(i, j) = var * var;
			}
	} else if(rhs == (Tfloat)0.5) {
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				a.elem(i, j) = sqrt(elemc(i, j));
	} else {
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				a.elem(i, j) = pow(elemc(i, j), rhs);
	}

	return a;
}

////////////////////////////
//Other/////////////////////

void Matrice::symetrize()
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();
	if(_rows != _cols) {
		LOGE(TAG, "\nSorry!!!! Not square matrix!\n");
		return;
	}

	for(i = 0; i < _rows; i++)
		for(j = i + 1; j < _rows; j++)
			elem(i, j) = elem(j, i) = (elem(i, j) + elem(j, i)) / 2.;
}

//dot product
Tfloat Matrice::dot(Matrice &A)
{
	int max_dim;
	int i;
	Tfloat result = 0;

	if(this->rows()*this->cols() != A.rows()*A.cols()) {
		return 0;
	} else {
		max_dim = this->rows() * this->cols();
		if(max_dim != this->rows() && max_dim != this->cols()) {
			LOGE(TAG, "\n\n This matrice is not one dimensional so we can not use function 'dot'! \n\n");
			return 0;
		}

		if(max_dim != A.rows() && max_dim != A.cols()) {
			LOGE(TAG, "\n\n Input is not one dimensional so we can not use function 'dot'! \n\n");
			return 0;
		}

		if(this->rows() == 1 || this->cols() == 1) {
			if(A.rows() == 1 || A.cols() == 1) {
				for(i = 0 ; i < max_dim ; i++)
					result += (*this)[i] * A[i];
			}
			return result;
		} else
			return 0;
	}
}

Matrice Matrice::cross(Matrice &A)
{
	Matrice res(3, 1);//////////////////////////////////////////////////////////////////////////////////////////////

	res(0, 0) = (*this)[1] * A[2] - (*this)[2] * A[1];
	res(1, 0) = (*this)[2] * A[0] - (*this)[0] * A[2];
	res(2, 0) = (*this)[0] * A[1] - (*this)[1] * A[0];

	return res;
}

int Matrice::normalize()
{
	int i, j;
	Tfloat norm = 0;
	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++)
			norm += pow(elem(i, j), 2);
	norm = sqrt(norm);
	if(norm > 1e-7) {
		for(i = 0; i < rows(); i++)
			for(j = 0; j < cols(); j++)
				elem(i, j) /= norm;
		return 1;
	} else
		return 0;
}

Tfloat Matrice::norm()
{
	int i, j;
	Tfloat sum = 0;
	Tfloat val;
	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++) {
			val = elem(i, j);
			sum += val * val;
		}
	return sqrt(sum);
}

Tfloat Matrice::length()
{
	return norm();
}

Tfloat Matrice::norm2()
{
	int i, j;
	Tfloat sum = 0;
	Tfloat val;
	for(i = 0; i < rows(); i++)
		for(j = 0; j < cols(); j++) {
			val = elem(i, j);
			sum += val * val;
		}
	return sum;
}

Tfloat Matrice::length2()
{
	return norm2();
}

Tfloat Matrice::rms()
{
	return norm() / sqrt(rows() * cols());
}

Tfloat Matrice::trace()
{
	int i, dim;
	Tfloat sum = 0;
	dim = cols() < rows() ? cols() : rows();
	for(i = 0; i < dim; i++)
		sum += elem(i, i);
	return sum;
}

Tfloat Matrice::maxim()
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	Tfloat val = elemc(0, 0);
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			val = val > elemc(i, j) ? val : elemc(i, j);

	return val;
}

Tfloat Matrice::minim()
{
	int i, j;
	int _rows, _cols;
	_rows = rows(); _cols = cols();

	Tfloat val = elemc(0, 0);
	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++)
			val = val < elemc(i, j) ? val : elemc(i, j);

	return val;
}

//Median///////////////////////////////////////////////

#if 0
//locks when all data are equal
static int depth;
Tfloat findMedian(Tfloat *arr, const int &n);

int partition(Tfloat *arr, const int &l, const int &r, const int &pivot_i);
Tfloat medianOfMedians(Tfloat *arr, const int &l, const int &r, const int &k);

// partition the sub-array arr[l..r] around pivot
// pivot_i: the index of pivot
// return the position of the pivot after partition
int partition(Tfloat *arr, const int &l, const int &r, const int &pivot_i)
{
	// swap pivot with the last element
	const Tfloat pivot = arr[pivot_i];
	if(pivot_i != r)
		std::swap(arr[pivot_i], arr[r]);
	//const Tfloat pivot = arr[pivot_i];

	// do partition
	int chg = l;
	for(int i = l; i <= r - 1; ++i) {
		if(arr[i] <= pivot) {
			std::swap(arr[chg], arr[i]); // ensure that i's left elements are less than the pivot
			chg++;
		}
	}
	std::swap(arr[chg], arr[r]); // swap back the pivot; finish partition
	return chg;                  // return the position of the pivot
}

const int GROUP_NUM = 5; // number of elements in a group (used in Median of Medians algorithm)
// Median of medians algorithm: find k th smallest number in the sub-array[l..r]
Tfloat medianOfMedians(Tfloat *arr, const int &l, const int &r, const int &k)
{
	int n = r - l + 1; // length of the sub array

	// if k is out of range, throw exception
	assert(k > 0 && k <= n);
	assert(depth < 10);

	// divide sub-arrary[l..r] in groups of size GROUP_NUM (the last group length can be less than GROUP_NUM)
	// calculate median of each groups and store them in median array
	int const medianNum = static_cast<int>(ceil(static_cast<double>(n) / static_cast<double>(GROUP_NUM)));
	//int const medianNum = (n + 4) / GROUP_NUM;
	Tfloat median[medianNum];
	int median_i;
	for(median_i = 0; median_i < n / GROUP_NUM; ++median_i)
		median[median_i] = findMedian(arr + l + median_i * GROUP_NUM, GROUP_NUM);
	if(median_i * GROUP_NUM < n) {  // last group with elements less than GROUP_NUM
		median[median_i] = findMedian(arr + l + median_i * GROUP_NUM, n % GROUP_NUM);
	}

	// Find median of all medians recursively
	Tfloat medOfMedians;
	if(medianNum == 1)  // first median is the median of medians since there's only one median
		medOfMedians = median[0];
	else {
		// we don't need to consider odd and even array length cases,
		// since this median is used for partition
		medOfMedians = medianOfMedians(median, 0, medianNum - 1, medianNum / 2);
	}

	// get the medOfMedians's index
	int pivot_i;
	for(pivot_i = l; pivot_i < r; ++pivot_i) {
		if(arr[pivot_i] == medOfMedians)
			break;
	}
	// partition the array around median of medians
	int pos = partition(arr, l, r, pivot_i);

	if(pos - l + 1 == k)  // if the pos is the kth number, return it
		return arr[pos];
	if(pos - l + 1 > k)   // if position is more than kth, find kth within left sub-array
		return medianOfMedians(arr, l, pos - 1, k);
	else                  // if position is less than kth, find kth within right sub-array
		return medianOfMedians(arr, pos + 1, r, k - pos + l - 1);
}

// Quick select algorithm: find k th smallest number in the sub-array[l..r]
Tfloat quickSelect(Tfloat *arr, const int &l, const int &r, const int &k)
{

	const int n = r - l + 1;
	// if k is out of range, throw exception
	assert(k > 0 && k <= n);

	int pivot_i = l + rand() % n; // random pick up a pivot

	// partition arr[l..r] around pivot
	int pos = partition(arr, l, r, pivot_i);

	if(pos - l + 1 == k)      // if the pos is the kth number, return it
		return arr[pos];
	else if(pos - l + 1 > k)  // if position is more than kth, find kth within left sub-array
		return quickSelect(arr, l, pos - 1, k);
	else                      // if position is less than kth, find kth within right sub-array
		return quickSelect(arr, pos + 1, r, k - pos + l - 1);
}
#endif

#if 0
//#if defined(__linux__) || defined(__WIN32__)
//Slower but robust
// sort the array arr of size n and return its median
Tfloat findMedian(Tfloat *arr, const int &n)
{
	assert(n >= 1);
	if(n == 1)
		return *arr;
	std::sort(arr, arr + n);  // Sort the array
	// we don't need to consider odd and even array length cases,
	// since this median is used for partition
	return arr[n / 2];
}

Tfloat Matrice::median()
{
	int i, j, _rows, _cols, count;
	_rows = rows(); _cols = cols();
	uint32_t n = _cols * _rows;
	//depth = 0;
	count = 0;
	assert(n > 0);

	Tfloat* a = (Tfloat*)malloc(n * sizeof(Tfloat));

	if(_rows == 1) {
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _cols; j++)
				a[count++] = elem(i, j);
	} else {
		for(j = 0; j < _cols; j++)
			for(i = 0; i < _rows; i++)
				a[count++] = elem(i, j);
	}

	/*int left = 0;
	int right = n;
	int k = n >> 1;
	Tfloat med = medianOfMedians(a, left, right, k); //O(n)
	*/
	Tfloat med = findMedian(a, n);

	free(a);

	return med;
}

#endif

////////////////////////////

Matrice Matrice::abs()
{
	int i, j;
	int _rows, _cols;
	register Tfloat val;
	_rows = rows(); _cols = cols();
	Matrice result(_rows, _cols);/////////////////////////////////////////////////////////////////////

	for(i = 0; i < _rows; i++)
		for(j = 0; j < _cols; j++) {
			val = elem(i, j);
			result.elem(i, j) = val > 0 ? val : -val;
		}
	return result;
}

//Inverses//////////////////
///For better performance, see https://github.com/willnode/N-Matrix-Programmer/blob/master/Info/Matrix_10x10.txt
//O(n3) (like matrix multiplication)
//DEFINITION_2D, IGNORE_MOVE
//1000 corei7(6770HQ)->13.75
//500 corei7(6770HQ)->2.360
//250 corei7(6770HQ)->0.375
//verified
Matrice Matrice::inverse()
{
	int i, j, k;
	Tfloat ratio, d;
	int _rows, _cols;
	Matrice tmp;/////////////////////////////////////////////////////////////////////////////////////
	Matrice result;/////////////////////////////////////////////////////////////////////////////////////

	_rows = rows(); _cols = cols();

	tmp.reinit(_rows, _cols);
	result.reinit(_rows, _cols);

	tmp = (*this);

	if(_rows != _cols) {
		result.p->error = -1;
		LOGE(TAG, "\n Matrix not square!\n\n");
		return result;
	}

	if(_rows == 1) {
		if(this->elem(0, 0) == 0) {
			result.p->error = -1;
			//LOGE(TAG,"\n Matrix does not have inverse1!\n\n");
			return result;
		} else
			result.elem(0, 0) = 1. / this->elem(0, 0);
	} else {  //************** Gauss Jordan method for inverse matrix *******************
		//https://ganeshtiwaridotcomdotnp.blogspot.in/2009/12/c-c-code-gauss-jordan-method-for.html
		//is of order O(n^3) like matrix multiplication
		//can be used up to thousands of equations
		//but LU decomposition is better
#define SWAP(a,b) {d=a;a=b;b=d;}

		//fill Identity
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _rows; j++)
				result.elem(i, j) = (i == j ? 1.0 : 0.0);

		//printf("\n\n  before pivoting A Is:\n\n");
		// print(A,A.d1_,A.d2_);
		//************* partial pivoting **************
		//for the case A(i,i) == 0, swap rows

		for(i = _rows - 1; i > 0; i--)
			if(tmp.elem(i - 1, 0) < tmp.elem(i, 0)) {
				for(j = 0; j < _rows; j++) {
					SWAP(tmp.elem(i, j), tmp.elem(i - 1, j))
					SWAP(result.elem(i, j), result.elem(i - 1, j))
				}
			}

		//	printf("\n\n Tmp Is:\n\n");
		// print(Tmp,Tmp.d1_,Tmp.d2_);
		// 	printf("\n\n after pivoting A Is:\n\n");
		//   print(A,A.d1_,A.d2_);
		//********* reducing to diagonal  matrix ***********
		//********* This part takes 99% of time, can be parallelized or sparcified***********
		for(i = 0; i < _rows; i++)
			for(j = 0; j < _rows; j++) //rows()*2 is wrong in reference
				if(i != j) {
					if(tmp.elem(i, i) == 0) {
						result.p->error = -2;
						//LOGE(TAG,"\n Matrix does not have inverse2!\n\n");
					}
					ratio = tmp.elem(j, i) / tmp.elem(i, i);
					for(k = 0; k < _rows; k++) {
						tmp.elem(j, k) -= ratio * tmp.elem(i, k);
						result.elem(j, k) -= ratio * result.elem(i, k);
					}
				}
		//printf("-%f\n", myTime() - time_s); time_s = myTime();

		//************* reducing to unit matrix *************
		for(i = 0; i < _rows; i++) {
			d = tmp.elem(i, i);
			if(d == 0) {
				result.p->error = -3;
				//LOGE(TAG,"\n Matrix does not have inverse3!\n\n");
			}
			d = 1. / d;
			for(j = 0; j < _rows; j++) {
				tmp.elem(i, j) *= d;
				result.elem(i, j) *= d;
			}
		}
	}
	//result=tmp;
	return result;
}

//Another lgorithm present in nsrMatLibInv.cpp
//ref:https://www.tutorialspoint.com/cplusplus-program-to-compute-determinant-of-a-matrix
/*#if defined(__linux__) || defined(__WIN32__)
//recursive algorithm not appropriate for microcontrollers
Tfloat Matrice::determinant()
{
    int n, x, i, j, subi, subj;

    n = rows();
	assert(n > 0);
    assert(rows() == cols());

    if (n == 1)
        return elemc(0, 0);

    if (n == 2)
        return ((elemc(0, 0) * elemc(1, 1)) - (elemc(1, 0) * elemc(0, 1)));

	Tfloat det = 0;
	Matrice submatrix(n - 1, n - 1); ///////////////////////////////////////////

	for (x = 0; x < n; x++) {
		subi = 0;
		for (i = 1; i < n; i++) {
			subj = 0;
			for (j = 0; j < n; j++) {
				if (j == x) continue;
				submatrix.elem(subi, subj) = elemc(i, j);
				subj++;
			}
			subi++;
		}
		det += (x % 2 == 0 ? 1 : -1) * elemc(0, x) * submatrix.determinant();
	}

    return det;
}
#endif*/

#ifdef __cplusplus
}
#endif
